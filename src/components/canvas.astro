---

---

<div class="canvas-container">
	<canvas id="canvas-main"></canvas>
	<canvas id="canvas-pixel"></canvas>
	<div class="control-container text-white text-line-reversed">
		<div class="row">
			<span class="text-background"> Edit Anim Specs:</span>
		</div>
		<div class="row">
			<div class="text-background">
				<label for="rings">_Num_Rings:</label>
				<input
					class="editable"
					type="number"
					id="rings"
					name="rings"
					min="1"
					max="20"
					value="8"
					step="1"
				/>
			</div>
		</div>
		<div class="row">
			<div class="text-background">
				<label for="speed">_Speed:</label>
				<input
					class="editable"
					type="number"
					id="speed"
					name="speed"
					min="-0.1"
					max="0.1"
					value="0.01"
					step="0.01"
				/>
			</div>
		</div>
	</div>
</div>

<script is:inline>
	document.addEventListener('DOMContentLoaded', () => {
		let ctxMain, ctxPixel
		let grdAngle = 0
		let grdRotation = 0.02
		let grdAngleOffset = 0.5

		const pixelScale = 20
		const canvasSpan = 0.9
		const density = '#▚◥❌♥♦@8²Å╱←£✓*?!~:. '
		const fps = 29
		const interval = 1000 / fps
		let then, now, delta
		const pixelRatio = window.devicePixelRatio || 1

		const canvasMain = document.getElementById('canvas-main')
		const canvasPixel = document.getElementById('canvas-pixel')

		let speed = 0.01
		let isAnimating = true

		const setCanvasSize = () => {
			const windowWidth = Math.floor(window.innerWidth * canvasSpan)
			const windowHeight = Math.floor(window.innerHeight * canvasSpan)
			const pixelWidth = Math.ceil(window.innerWidth / pixelScale)
			const pixelHeight = Math.ceil(window.innerHeight / pixelScale)

			ctxMain = canvasMain.getContext('2d')
			ctxMain.canvas.width = Math.floor(window.innerWidth * pixelRatio * canvasSpan)
			ctxMain.canvas.height = Math.floor(window.innerHeight * pixelRatio * canvasSpan)
			canvasMain.style.width = `${windowWidth}px`
			canvasMain.style.height = `${windowHeight}px`

			ctxPixel = canvasPixel.getContext('2d', { willReadFrequently: true })
			ctxPixel.canvas.width = Math.ceil((window.innerWidth / pixelScale) * pixelRatio)
			ctxPixel.canvas.height = Math.ceil((window.innerHeight / pixelScale) * pixelRatio)
			canvasPixel.style.width = `${pixelWidth}px`
			canvasPixel.style.height = `${pixelHeight}px`
		}

		const drawGrad = () => {
			const offSet = 1
			const maxRadius = Math.min(ctxPixel.canvas.width, ctxPixel.canvas.height) / 2 - offSet
			const cX = ctxPixel.canvas.width / 2
			const cY = ctxPixel.canvas.height / 2 + offSet

			ctxPixel.fillStyle = 'rgba(0, 0, 0, 1)'
			ctxPixel.beginPath()
			ctxPixel.arc(cX, cY, maxRadius, 0, 2 * Math.PI)
			ctxPixel.fill()
			ctxPixel.closePath()

			const numOfRings = document.querySelector('input#rings').value
			const initialAngle = grdAngle
			const ringScaleStep = maxRadius / numOfRings

			for (let x = 0; x < numOfRings; x++) {
				const ringScale = ringScaleStep * x
				const grd = ctxPixel.createConicGradient(
					initialAngle + (grdAngle + grdAngleOffset) * x,
					cX,
					cY
				)
				grd.addColorStop(0.25, 'rgb(0,0,0)')
				grd.addColorStop(1, 'rgb(125,125,125)')
				ctxPixel.fillStyle = grd

				ctxPixel.beginPath()
				ctxPixel.arc(cX, cY, maxRadius - ringScale, 0, 2 * Math.PI)
				ctxPixel.fill()
			}

			grdAngle += speed

			ctxPixel.translate(cX, cY)
			ctxPixel.rotate(grdRotation)
			ctxPixel.translate(-cX, -cY)
		}

		const updateAnimation = () => {
			if (!isAnimating) return

			ctxMain.fillStyle = 'rgba(0, 0, 0, 1)'
			ctxMain.fillRect(0, 0, ctxMain.canvas.width, ctxMain.canvas.height)
			drawGrad()

			const imageData = ctxPixel.getImageData(0, 0, ctxPixel.canvas.width, ctxPixel.canvas.height)
			const w = (ctxPixel.canvas.width / imageData.width) * pixelScale * canvasSpan
			const h = (ctxPixel.canvas.height / imageData.height) * pixelScale * canvasSpan

			const data = imageData.data
			for (let col = 0; col < imageData.height; col++) {
				for (let row = 0; row < imageData.width; row++) {
					const pixelIndex = (row + col * imageData.width) * 4
					const avg = Math.floor(
						(data[pixelIndex] + data[pixelIndex + 1] + data[pixelIndex + 2]) / 3
					)
					drawAscii(row, col, w, h, avg)
				}
			}
		}

		const drawAscii = (row, col, w, h, avg) => {
			const len = density.length
			const charIndex = Math.floor(scale(avg, 0, 255, len, 0))
			ctxMain.font = `${h}px "c64"`
			ctxMain.textAlign = 'left'
			ctxMain.fillStyle = 'rgb(150, 145, 130)'
			ctxMain.fillText(density.charAt(charIndex), row * w, col * h)
		}

		const scale = (number, inMin, inMax, outMin, outMax) => {
			return ((number - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin
		}

		const animateFrames = () => {
			if (isAnimating) {
				requestAnimationFrame(animateFrames)
			}
			now = Date.now()
			delta = now - then

			if (delta > interval) {
				updateAnimation()
				then = now - (delta % interval)
			}
		}

		setCanvasSize()
		window.addEventListener('resize', setCanvasSize)
		then = Date.now()
		animateFrames()

		document.querySelector('input#speed').addEventListener('change', (e) => {
			speed = parseFloat(e.target.value)
		})

		// Intersection Observer setup
		const options = {
			root: null,
			threshold: 0,
			rootMargin: '-20% 0px'
		}

		const canvasObserver = new IntersectionObserver((entries) => {
			entries.forEach((entry) => {
				if (!entry.isIntersecting) {
					isAnimating = false
				} else {
					isAnimating = true
					animateFrames()
				}
			})
		}, options)

		const canvasEl = document.querySelectorAll('canvas')
		canvasObserver.observe(canvasEl[0])

		document.addEventListener('visibilitychange', () => {
			if (document.hidden) {
				isAnimating = false
			} else {
				isAnimating = true
				animateFrames()
			}
		})
	})
</script>

<style>
	#canvas-main {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 100%;
		height: 100%;
		z-index: 2;
	}

	#canvas-pixel {
		display: none;
	}

	.control-container {
		z-index: 2;
		position: absolute;
		min-width: calc(20% - 2rem);
		right: 2rem;
		bottom: calc(5% + 2rem);
		display: flex;
		flex-direction: column;
		gap: 0.1rem;
	}

	.control-container label,
	.control-container input,
	.control-container span {
		color: #969182;
		font-size: 0.8rem;
	}

	.control-container input[type='number'] {
		background-color: var(--black);
		border: 0px solid;
		border-bottom: 1px solid #969182;
		padding: 0;
		text-align: center;
	}

	.control-container .editable::-webkit-inner-spin-button,
	.control-container .editable::-webkit-outer-spin-button {
		opacity: 1;
		display: none;
	}

	.control-container .text-background {
		display: inline;
	}

	@media (max-width: 640px) {
		#canvas-main {
			max-width: 100%;
		}

		.control-container {
			display: none;
		}
	}

	@media (max-height: 350px) {
		.control-container {
			display: none;
		}
	}
</style>
